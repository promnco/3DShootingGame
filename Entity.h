// Entity はデータ構造であり、行動の実装はコンポーネントに分割していく。
// これにより、よりコンポーネント指向 (ECS) に適した設計となる。
// 特殊な行動（入力処理やAIなど）は、PlayerEntity や EnemyEntity のように派生クラスで持つのがオブジェクト指向 (OOP) 的な解法。

// オブジェクト指向 (OOP) の考え方:
// プログラムをオブジェクト（データとその操作をまとめたもの）として捉え、
// オブジェクト同士の相互作用を通じてプログラムを構築する。

// コンポーネント指向 (ECS) の考え方:
// プログラムを小さな部品（コンポーネント）に分割し、それらを組み合わせて機能を実現する。

// ２つの違い:
// オブジェクト指向はオブジェクト同士の相互作用を重視し、
// コンポーネント指向は部品の再利用性や組み合わせの柔軟性を重視する。

// ２つを組み合わせる場合:
// オブジェクト指向のクラスをコンポーネントとして扱い、
// それらを組み合わせてエンティティを構成することができる。
// これにより、オブジェクト指向の利点（カプセル化、継承、多態性）を活かしつつ、
// コンポーネント指向の利点（再利用性、柔軟性）も享受できる。

#pragma once
#include "Component.h"
#include <vector>           // コンポーネントを格納するための動的配列
#include <memory>           // スマートポインタを使うためのヘッダーファイル

// ゲーム内のエンティティを表現する基本クラス
class Entity
{
public:

    // デストラクタ
    virtual ~Entity() {}

    // エンティティに新しいコンポーネントを追加
	// std;;shared_ptr<Component>はC++11以降のスマートポインタ
	// スマートポインタとは、リソースの自動管理を提供し、メモリリークを防ぐために使用される。
    // std::shared_ptr<Component> を使うことで、コンポーネントの所有権はエンティティに委譲されない（リソース管理が自動化される）
	// そのため、エンティティが破棄されると、関連するコンポーネントも自動的に破棄される。
    void AddComponent(std::shared_ptr<Component> component);

	// Entity(GameObject)のコンポーネントを作成する関数
	// void Create(std::shared_ptr<Component> component);

    // エンティティの更新処理：各エンティティごとに個別に実装される
    virtual void Update();

    // エンティティの描画処理：各エンティティごとに個別に実装される
    virtual void Draw();

	// 弾が当たった時にモデルの描画に影響を与えるかどうかを示すフラグ
    bool active = true;

protected:
    // コンポーネントのリスト：エンティティが持つコンポーネントを格納する
    std::vector<std::shared_ptr<Component>> m_components;
};